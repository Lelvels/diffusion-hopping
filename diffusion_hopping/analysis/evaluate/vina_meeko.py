
import vina
from meeko import MoleculePreparation
from io import StringIO
from pathlib import Path
import vina
from meeko import MoleculePreparation
from io import StringIO
from pathlib import Path
import subprocess
import sys

def _prepare_protein(protein_path) -> Path:
    protein_folder = protein_path.parent.resolve()
    protein_pdbqt = protein_folder / f"{protein_path.stem}.pdbqt"
    
    # Optional: Check if already exists? 
    # But usually we might want to ensure it's fresh or if parameters changed.
    # For efficiency in evaluation loop, we can check existence.
    if protein_pdbqt.exists():
        return protein_pdbqt

    # Use obabel to convert PDB to PDBQT
    # -xr: output rigid molecule
    # --partialcharge gasteiger: add gasteiger charges
    # -p 7.4: add hydrogens at pH 7.4
    command = [
        "obabel",
        str(protein_path),
        "-O",
        str(protein_pdbqt),
        "-xr",
        "--partialcharge", "gasteiger",
        "-p", "7.4"
    ]
    
    try:
        subprocess.run(
            command, 
            check=True, 
            capture_output=True, 
            text=True
        )
    except subprocess.CalledProcessError as e:
        print(f"Obabel protein preparation failed: {e.stderr}")
        raise e
        
    return protein_pdbqt


def vina_meeko_score(row, size=20.0, exhaustiveness=8):
    """
    Calculate Vina score using Meeko for ligand preparation and Vina Python API.
    
    Args:
        row: DataFrame row containing molecule and protein information.
        size: Box size (Angstroms).
        exhaustiveness: Search exhaustiveness.
        
    Returns:
        float: Vina affinity score.
    """
    try:
        if row["molecule"] is None:
            return None
            
        protein_path = row["test_set_item"]["protein"].path
        ligand_mol = row["molecule"]
        
        # Prepare protein (convert to PDBQT if needed)
        # We reuse the existing _prepare_protein helper which handles PDB -> PDBQT
        # conversion using mgltools or equivalent if available.
        # However, checking compatibility: Vina 1.2+ Python API defaults to PDBQT.
        # Let's use the standard PDBQT file generated by the existing helper.
        protein_pdbqt = _prepare_protein(protein_path)
        
        return _calculate_vina_meeko_score(
            protein_pdbqt,
            ligand_mol,
            size=size,
            exhaustiveness=exhaustiveness
        )
    except Exception as e:
        print(f"Error in vina_meeko_score: {e}")
        return None

def _calculate_vina_meeko_score(protein_pdbqt_path, ligand_mol, size=20.0, exhaustiveness=8):
    # 1. Prepare Ligand with Meeko
    try:
        from meeko import MoleculePreparation, PDBQTWriterLegacy
        from rdkit import Chem
        
        # Meeko requires explicit hydrogens
        ligand_mol = Chem.AddHs(ligand_mol, addCoords=True)
        
        preparator = MoleculePreparation()
        mol_setups = preparator.prepare(ligand_mol)
        # prepare() returns a list of MoleculeSetup instances
        if not mol_setups:
            raise ValueError("Meeko failed to prepare molecule (no setups returned)")
            
        writer = PDBQTWriterLegacy()
        # write_string returns (pdbqt_string, success, error_msg)
        ligand_pdbqt_string, is_ok, error_msg = writer.write_string(mol_setups[0])
        if not is_ok:
            raise ValueError(f"Meeko failed to write PDBQT string: {error_msg}")
    except Exception as e:
        print(f"Meeko preparation failed: {e}")
        return None

    # 2. Setup Vina
    v = vina.Vina(sf_name='vina')
    
    # Load receptor
    # string path for set_receptor
    v.set_receptor(str(protein_pdbqt_path.resolve()))
    
    # Load ligand from string
    v.set_ligand_from_string(ligand_pdbqt_string)
    
    # 3. Compute Map (Box Center)
    # Get center from RDKit molecule
    center = ligand_mol.GetConformer().GetPositions().mean(axis=0)
    
    v.compute_vina_maps(center=[center[0], center[1], center[2]], box_size=[size, size, size])
    
    # 4. Score (Minimize)
    # We want to score the CURRENT pose (minimized), similar to --minimize in gnina/vina
    # 'score()' method calculates the score of the current pose.
    # 'optimize()' minimizes the current pose.
    # Usually 'score' is what we want for "evaluating generated molecules" if we trust the generation,
    # but often we allow some local minimization (re-docking / refinement).
    # gnina logic used --minimize.
    # qvina logic used simple scoring? No, qvina command was:
    # qvina2.1 --receptor ... --ligand ... ... (defaults to docking?)
    # Wait, qvina_score constructs a command: "qvina2.1 ... --exhaustiveness ..."
    # It does NOT say --score_only. It runs docking!
    # Let's check qvina.py again.
    # "qvina2.1 --receptor ... --ligand ... ... --exhaustiveness ..."
    # This runs DOCKING (global search) because exhaustiveness is set.
    # The user request for this new tool: "add another vina calculation"
    # Usually "calculation" implies re-docking or scoring.
    # The gnina script used `--minimize`.
    # Let's stick to DOCKING since `qvina_score` does docking.
    # gnina_score used --minimize.
    # I should align with what is expected.
    # If the user wants to compare with gnina which uses --minimize, maybe I should minimize?
    # But qvina_score runs full docking.
    # The request is likely for a "Vina score" metric.
    # If I just want the score of the generated pose => v.score()
    # If I want the best possible docking score => v.dock()
    # Given `qvina_score` performs docking (finding best pose), I should probably do `dock()`.
    
    v.dock(exhaustiveness=exhaustiveness, n_poses=1)
    
    # Get the best score
    # energies() returns list of [energy, dist_lb, dist_ub] (or numpy array)
    energies = v.energies(n_poses=1)
    
    # Check if energies is not empty. Safe for list and numpy array
    if energies is not None and len(energies) > 0:
        return energies[0][0]
    
    return None
